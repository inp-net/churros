import { execSync } from 'child_process';
import { existsSync, readdirSync, readFileSync, statSync, writeFileSync } from 'fs';
import { glob } from 'glob';
import path from 'node:path';

const main = () => {
  const currentDirectory = process.cwd();
  const topLevelGitDirectory = execSync('git rev-parse --show-toplevel', {
    encoding: 'utf-8',
  }).trim();

  if (currentDirectory !== `${topLevelGitDirectory}/packages/api`) {
    console.log('Please run this script from packages/api');
    process.exit(1);
  }

  const barrelsbyConfigPath = 'barrelsby.config.json';
  let barrelsbyConfig: any;

  if (existsSync(barrelsbyConfigPath)) {
    barrelsbyConfig = JSON.parse(readFileSync(barrelsbyConfigPath, 'utf-8'));
  } else {
    barrelsbyConfig = { directory: [] };
  }

  barrelsbyConfig.directory = [];

  writeFileSync(barrelsbyConfigPath, JSON.stringify(barrelsbyConfig, undefined, 2));

  const generateBarrelsByConfig = (dirPath: string) => {
    const dirs = glob.sync(dirPath);
    for (const dir of dirs) {
      if (!existsSync(dir)) {
        continue;
      }

      if (!statSync(dir).isDirectory()) {
        continue;
      }

      if (!readdirSync(dir).length) {
        continue;
      }

      if (!readdirSync(dir).some((file) => file.endsWith('.ts'))) {
        continue;
      }

      barrelsbyConfig.directory.push(`./${dir}`);
    }
  };

  generateBarrelsByConfig('src/lib');
  generateBarrelsByConfig('src/permissions');
  generateBarrelsByConfig('src/modules/*/*');
  barrelsbyConfig.directory = Array.from(new Set(barrelsbyConfig.directory)).sort();
  writeFileSync(barrelsbyConfigPath, JSON.stringify(barrelsbyConfig, undefined, 2) + '\n');

  console.log('Updated barrelsby.config.json');

  const generatedModulesNames: string[] = [];

  for (const module of readdirSync('src/modules')) {
    const modulePath = `src/modules/${module}`;

    if (!existsSync(modulePath)) {
      continue;
    }

    const moduleName = module;

    const moduleIndexContent = `/**
 * @file generated by packages/api/scripts/generate-barrelsby-config.ts
 * The order of imports matters to Pothos, so we need to hardcode the import order,
 * barrelsby cannot do this, so we do it ourselves with a little bash scripting.
 */

// organize-imports-ignore
${existsSync(`${modulePath}/types/`) ? `export * from './types/index.js';\n` : ''}${existsSync(`${modulePath}/resolvers/`) ? `export * from './resolvers/index.js';\n\n` : ''}`;

    writeFileSync(`${modulePath}/index.ts`, moduleIndexContent);

    for (const dir of readdirSync(modulePath)) {
      const fullPath = `${modulePath}/${dir}`;

      if (!existsSync(fullPath)) {
        continue;
      }

      if (!statSync(fullPath).isDirectory()) {
        continue;
      }

      if (!readdirSync(fullPath).filter((p) => ['.js', '.ts'].includes(path.extname(p))).length) {
        continue;
      }

      if (dir === 'resolvers' || dir === 'types') {
        continue;
      }

      writeFileSync(`${modulePath}/index.ts`, `export * from './${dir}/index.js';\n`, {
        flag: 'a',
      });
    }

    writeFileSync(`${modulePath}/index.ts`, '\n', { flag: 'a' });

    generatedModulesNames.push(moduleName);
  }

  console.log('Generated index.ts for modules', ...generatedModulesNames);
};

main();
