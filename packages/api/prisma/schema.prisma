generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["fullTextSearch", "postgresqlExtensions"]
}

// See https://pothos-graphql.dev/docs/plugins/prisma#setup
generator pothos {
  provider = "prisma-pothos-types"
}

datasource db {
  provider   = "postgresql"
  url        = env("DATABASE_URL")
  extensions = [fuzzystrmatch, pgcrypto, unaccent, pg_trgm]
}

/// Users are the people who use the app
model User {
  id        String   @id @default(dbgenerated("nanoid('u:')"))
  uid       String   @unique @db.VarChar(255)
  createdAt DateTime @default(now())

  // School details
  schoolServer String? @db.VarChar(255)
  schoolUid    String? @db.VarChar(255)
  schoolEmail  String? @db.VarChar(255)

  // Mandatory profile details
  email                        String                @unique @db.VarChar(255)
  otherEmails                  String[]              @db.VarChar(255)
  firstName                    String                @db.VarChar(255)
  lastName                     String                @db.VarChar(255)
  majorId                      String?
  major                        Major?                @relation(fields: [majorId], references: [id], onUpdate: Cascade, onDelete: Restrict)
  minor                        Minor?                @relation(fields: [minorId], references: [id])
  minorId                      String?
  graduationYear               Int
  apprentice                   Boolean               @default(false)
  address                      String                @default("") @db.VarChar(255)
  birthday                     DateTime?
  description                  String                @default("") @db.Text
  nickname                     String                @default("") @db.VarChar(255)
  phone                        String                @default("") @db.VarChar(255)
  pictureFile                  String                @default("") @db.VarChar(255)
  links                        Link[]
  godparentId                  String?
  cededImageRightsToTVn7       Boolean               @default(false)
  enabledNotificationChannels  NotificationChannel[] @default([Articles, Shotguns, Permissions, GroupBoard, GodparentRequests, Comments, Other])
  latestVersionSeenInChangelog String                @default("0.0.0")

  // Permissions
  admin              Boolean @default(false)
  canEditUsers       Boolean @default(false)
  canEditGroups      Boolean @default(false)
  canAccessDocuments Boolean @default(false)

  // Relationships
  articles                  Article[]
  groups                    GroupMember[]
  credentials               Credential[]
  Reservation               Registration[]             @relation("author")
  managedEvents             EventManager[]
  logs                      LogEntry[]
  events                    Event[]
  notificationSubscriptions NotificationSubscription[]
  notifications             Notification[]
  godparent                 User?                      @relation("mentorship", fields: [godparentId], references: [id]) // Le parrain ou la marraine
  godchildren               User[]                     @relation("mentorship") // Les filleul(e)s
  incomingGodparentRequests GodparentRequest[]         @relation("godparent")
  outgoingGodparentRequests GodparentRequest[]         @relation("godchild")
  passwordResets            PasswordReset[]
  emailChanges              EmailChange[]
  Announcement              Announcement[]
  contributions             Contribution[]
  verifications             Registration[]             @relation("verifiedBy")
  oppositions               Registration[]             @relation("opposedBy")
  cancellations             Registration[]             @relation("cancelledBy")
  documents                 Document[]
  comments                  Comment[]
  bannedFromEvents          Event[]                    @relation("bannedFromEvents")
  reactions                 Reaction[]
  allowedApps               ThirdPartyApp[]

  // For full-text search
  search                Unsupported("tsvector") @default(dbgenerated("''::tsvector"))
  claimedPromotions     PromotionCode[]
  thirdPartyCredentials ThirdPartyCredential[]

  @@unique([schoolServer, schoolUid])
  @@index([search], type: Gin)
}

/// Requests to become someone's godchild. Gets deleted once the request has been accepted (or denied). godchild is the requester, godparent is the requested.
model GodparentRequest {
  id        String   @id @unique @default(dbgenerated("nanoid('godparentreq:')"))
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  godchild    User   @relation("godchild", fields: [godchildId], references: [id])
  godchildId  String
  godparent   User   @relation("godparent", fields: [godparentId], references: [id])
  godparentId String

  @@unique([godchildId, godparentId])
}

/// UserCandidates are users in the registration process
model UserCandidate {
  id        String   @id @default(dbgenerated("nanoid('candidate:')"))
  createdAt DateTime @default(now())

  email          String  @unique @db.VarChar(255)
  token          String  @unique
  emailValidated Boolean @default(false)

  schoolServer String? @db.VarChar(255)
  schoolUid    String? @db.VarChar(255)
  schoolEmail  String? @unique @db.VarChar(255)

  firstName      String  @default("") @db.VarChar(255)
  lastName       String  @default("") @db.VarChar(255)
  majorId        String?
  major          Major?  @relation(fields: [majorId], references: [id], onUpdate: Cascade, onDelete: Restrict)
  graduationYear Int?
  password       String  @default("") @db.VarChar(255)
  apprentice     Boolean @default(false)

  address  String    @default("") @db.VarChar(255)
  birthday DateTime?
  phone    String    @default("") @db.VarChar(255)

  cededImageRightsToTVn7 Boolean @default(false)

  @@unique([schoolServer, schoolUid])
}

/// A password reset token
model PasswordReset {
  id        String    @id @default(dbgenerated("nanoid('passreset:')"))
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  userId    String
  expiresAt DateTime?
}

/// A email validation request
model EmailChange {
  id        String    @id @default(dbgenerated("nanoid('emailchange:')"))
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  email     String
  expiresAt DateTime?
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  userId    String
  pending   Boolean   @default(true)
}

// Enum for the different kinds of logos
enum LogoSourceType {
  InternalLink
  ExternalLink
  GroupLogo
  Icon
}

/// A service
model Service {
  id                   String              @id @default(dbgenerated("nanoid('service:')"))
  name                 String              @db.VarChar(255)
  url                  String              @default("") @db.VarChar(255)
  description          String              @default("") @db.VarChar(255)
  logo                 String              @db.VarChar(255)
  logoSourceType       LogoSourceType
  schoolId             String?
  school               School?             @relation(fields: [schoolId], references: [id], onUpdate: Cascade, onDelete: SetNull)
  studentAssociationId String?
  studentAssociation   StudentAssociation? @relation(fields: [studentAssociationId], references: [id], onUpdate: Cascade, onDelete: SetNull)
  groupId              String?
  group                Group?              @relation(fields: [groupId], references: [id], onUpdate: Cascade, onDelete: SetNull)
  importance           Int                 @default(0)

  @@unique([schoolId, studentAssociationId, groupId, url])
  @@unique([schoolId, studentAssociationId, groupId, name])
}

/// A single external link
model Link {
  id        String   @id @default(dbgenerated("nanoid('link:')"))
  name      String   @db.VarChar(255)
  value     String   @db.VarChar(255)
  createdAt DateTime @default(now())

  // All resources that can have links
  User                 User?               @relation(fields: [userId], references: [id])
  userId               String?
  StudentAssociation   StudentAssociation? @relation(fields: [studentAssociationId], references: [id])
  studentAssociationId String?
  Group                Group?              @relation(fields: [groupId], references: [id])
  groupId              String?
  Article              Article?            @relation(fields: [articleId], references: [id])
  articleId            String?
  Event                Event?              @relation(fields: [eventId], references: [id])
  eventId              String?
  Ticket               Ticket?             @relation(fields: [ticketId], references: [id])
  ticketId             String?
  Notification         Notification?       @relation(fields: [notificationId], references: [id])
  notificationId       String?
  Subject              Subject?            @relation(fields: [subjectId], references: [id])
  subjectId            String?

  @@unique([name, userId, studentAssociationId, groupId, articleId, eventId, ticketId, notificationId, subjectId])
}

/// A school syllabus
model Major {
  id            String  @id @default(dbgenerated("nanoid('major:')"))
  uid           String  @unique @db.VarChar(255)
  name          String  @db.VarChar(255)
  shortName     String  @default("") @db.VarChar(255)
  ldapSchoolUid String? @db.VarChar(255)

  schools           School[]        @relation("MajorToSchool")
  ldapSchool        School?         @relation("ldapSchool", fields: [ldapSchoolUid], references: [uid], onUpdate: Cascade, onDelete: SetNull)
  students          User[]
  userCandidates    UserCandidate[]
  accessibleTickets Ticket[]
  subjects          Subject[]
  minors            Minor[]
}

model Minor {
  id        String    @id @default(dbgenerated("nanoid('minor:')"))
  name      String
  shortName String    @default("")
  uid       String
  majors    Major[]
  yearTier  Int
  subjects  Subject[]
  users     User[]

  @@unique([uid, yearTier])
}

model School {
  id                 String @id @default(dbgenerated("nanoid('school:')"))
  uid                String @unique @db.VarChar(255)
  name               String @db.VarChar(255)
  color              String @db.VarChar(7)
  internalMailDomain String @default("") @db.VarChar(255)
  description        String @default("") @db.Text
  address            String @default("") @db.VarChar(255)

  majors              Major[]              @relation("MajorToSchool")
  majorsLdapSchool    Major[]              @relation("ldapSchool")
  studentAssociations StudentAssociation[]
  accessibleTickets   Ticket[]
  contributionOptions ContributionOption[]
  services            Service[]
}

enum CredentialType {
  Password
  Token
}

/// A credential is a way to authenticate a user
model Credential {
  id        String         @id @default(dbgenerated("nanoid('credential:')"))
  userId    String
  name      String         @default("") @db.VarChar(255)
  type      CredentialType
  value     String         @db.VarChar(255)
  userAgent String         @default("") @db.VarChar(255)
  createdAt DateTime       @default(now())
  expiresAt DateTime?

  user User @relation(fields: [userId], references: [id], onUpdate: Cascade, onDelete: Cascade)
}

enum ThirdPartyCredentialType {
  AuthorizationCode
  AccessToken
}

/// A way to give Churros API access to third parties
model ThirdPartyCredential {
  id        String                   @id @default(dbgenerated("nanoid('token:')"))
  type      ThirdPartyCredentialType
  ownerId   String
  clientId  String
  client    ThirdPartyApp            @relation(fields: [clientId], references: [id], onUpdate: Cascade, onDelete: Cascade)
  owner     User                     @relation(fields: [ownerId], references: [id], onUpdate: Cascade, onDelete: Cascade)
  expiresAt DateTime?
  createdAt DateTime                 @default(now())
  // TODO scopes
  value     String                   @db.VarChar(255)
}

/// A third party service.
model ThirdPartyApp {
  id                  String                 @id @default(dbgenerated("nanoid('app:', 30)"))
  createdAt           DateTime               @default(now())
  updatedAt           DateTime?              @updatedAt
  ownerId             String
  owner               Group                  @relation(fields: [ownerId], references: [id], onUpdate: Cascade, onDelete: Cascade)
  name                String                 @unique @db.VarChar(255) // Names are unique to prevent identity theft
  description         String                 @default("") @db.VarChar(255)
  allowedRedirectUris String[]
  credentials         ThirdPartyCredential[]
  secret              String
  website             String
  faviconUrl          String                 @default("") @db.VarChar(255) // Computed from website if not provided
  active              Boolean                @default(false)
  users               User[]
}

/// There is one student association per school
model StudentAssociation {
  id          String  @id @default(dbgenerated("nanoid('ae:')"))
  uid         String? @unique @db.VarChar(255)
  description String  @default("") @db.Text
  schoolId    String
  name        String  @unique @db.VarChar(255)
  links       Link[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  school              School               @relation(fields: [schoolId], references: [id], onUpdate: Cascade, onDelete: Restrict)
  groups              Group[]
  lydiaAccounts       LydiaAccount[]
  contributionOptions ContributionOption[]
  services            Service[]
}

model Contribution {
  id            String             @id @default(dbgenerated("nanoid('contribution:')"))
  option        ContributionOption @relation(fields: [optionId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  optionId      String
  transaction   LydiaTransaction?
  transactionId String?
  user          User               @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  paid          Boolean            @default(false)
  userId        String

  @@unique([optionId, userId])
}

model ContributionOption {
  id             String               @id @default(dbgenerated("nanoid('contributionoption:')"))
  offeredIn      School               @relation(fields: [offeredInId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  offeredInId    String
  paysFor        StudentAssociation[]
  beneficiary    LydiaAccount?        @relation(fields: [lydiaAccountId], references: [id], onDelete: SetNull, onUpdate: Cascade)
  lydiaAccountId String?
  name           String
  price          Float
  contributions  Contribution[]
}

/// The different kinds of groups
enum GroupType {
  Association
  Club
  Group
  Integration
  StudentAssociationSection
  List
}

/// A group is a collection of users
model Group {
  id                   String    @id @default(dbgenerated("nanoid('g:')"))
  uid                  String    @unique @db.VarChar(255)
  parentId             String?
  /// Helper field to get a whole tree without processing all groups
  /// To be set to the group's id itself for root groups.
  familyId             String?
  schoolId             String?
  studentAssociationId String?
  pictureFile          String    @default("") @db.VarChar(255)
  pictureFileDark      String    @default("") @db.VarChar(255)
  name                 String    @db.VarChar(255)
  type                 GroupType
  color                String    @db.VarChar(7)
  selfJoinable         Boolean   @default(false)
  roomIsOpen           Boolean   @default(false)

  address         String @default("") @db.VarChar(255)
  description     String @default("") @db.VarChar(255)
  email           String @default("") @db.VarChar(255)
  longDescription String @default("")
  website         String @default("") @db.VarChar(255)
  ldapUid         String @default("") @db.VarChar(255)
  links           Link[]

  /// Parent group, from which this group inherits its permissions
  parent   Group?  @relation("parent", fields: [parentId], references: [id], onUpdate: Cascade, onDelete: Restrict)
  children Group[] @relation("parent")

  /// Family root, only created for performance reasons
  familyRoot     Group?  @relation("root", fields: [familyId], references: [id], onUpdate: Cascade, onDelete: Restrict)
  familyChildren Group[] @relation("root")

  /// Related clubs
  related   Group[] @relation("related")
  relatedTo Group[] @relation("related")

  articles           Article[]
  members            GroupMember[]
  studentAssociation StudentAssociation? @relation(fields: [studentAssociationId], references: [id], onUpdate: Cascade, onDelete: Restrict)
  events             Event[]
  coOrganizedEvents  Event[]             @relation("coOrganizer")
  lyiaAccounts       LydiaAccount[]
  tickets            Ticket[]            @relation("openTo")
  barWeeks           BarWeek[]
  services           Service[]

  notifications          Notification[]
  groupId                String?
  ticketGroupId          String?
  joinedByBookingTickets Ticket[]       @relation("autojoin")

  // For full-text search
  search         Unsupported("tsvector") @default(dbgenerated("''::tsvector"))
  thirdPartyApps ThirdPartyApp[]

  @@index([search], type: Gin)
}

/// The intermediate model between users and groups
model GroupMember {
  groupId         String
  memberId        String
  title           String   @default("") @db.VarChar(255)
  president       Boolean  @default(false)
  treasurer       Boolean  @default(false)
  vicePresident   Boolean  @default(false)
  secretary       Boolean  @default(false)
  canEditMembers  Boolean  @default(false)
  canEditArticles Boolean  @default(false)
  canScanEvents   Boolean  @default(false)
  createdAt       DateTime @default(now())

  group  Group @relation(fields: [groupId], references: [id], onUpdate: Cascade, onDelete: Cascade)
  member User  @relation(fields: [memberId], references: [id], onUpdate: Cascade, onDelete: Cascade)

  @@id([groupId, memberId])
}

/// An article is a post in a group
model Article {
  id          String     @id @default(dbgenerated("nanoid('a:')"))
  authorId    String?
  groupId     String
  uid         String     @db.VarChar(255)
  title       String     @db.VarChar(255)
  body        String     @db.Text
  published   Boolean    @default(false)
  visibility  Visibility @default(Private)
  createdAt   DateTime   @default(now())
  publishedAt DateTime   @default(now())
  notifiedAt  DateTime?  @default(now()) // to prevent old notifications before this was added. Another migration will remove this default value.
  pictureFile String     @default("") @db.VarChar(255)
  links       Link[]
  comments    Comment[]

  author    User?      @relation(fields: [authorId], references: [id], onUpdate: Cascade, onDelete: SetNull)
  group     Group      @relation(fields: [groupId], references: [id], onUpdate: Cascade, onDelete: Cascade)
  event     Event?     @relation(fields: [eventId], references: [id])
  eventId   String?
  reactions Reaction[]

  // For full-text search
  search Unsupported("tsvector") @default(dbgenerated("''::tsvector"))

  @@unique([groupId, uid])
  @@index([search], type: Gin)
}

enum EventFrequency {
  Once
  Weekly
  Monthly
  Biweekly
}

/// An event is a date, time and place, as well as an optional ticket
model Event {
  id             String         @id @default(dbgenerated("nanoid('e:')"))
  authorId       String?
  groupId        String
  contactMail    String
  beneficiary    LydiaAccount?  @relation(fields: [lydiaAccountId], references: [id])
  description    String         @db.Text
  uid            String         @db.VarChar(255)
  title          String         @db.VarChar(255)
  startsAt       DateTime
  endsAt         DateTime
  notifiedAt     DateTime?      @default(now()) // to prevent old notifications before this was added. Another migration will remove this default value.
  location       String         @default("") @db.VarChar(255)
  visibility     Visibility
  frequency      EventFrequency @default(Once)
  recurringUntil DateTime?
  pictureFile    String         @default("") @db.VarChar(255)
  managers       EventManager[]
  author         User?          @relation(fields: [authorId], references: [id], onUpdate: Cascade, onDelete: SetNull)
  group          Group          @relation(fields: [groupId], references: [id])
  coOrganizers   Group[]        @relation("coOrganizer")
  tickets        Ticket[]
  ticketGroups   TicketGroup[]
  articles       Article[]
  lydiaAccountId String?
  links          Link[]
  bannedUsers    User[]         @relation("bannedFromEvents")
  reactions      Reaction[]

  // For full-text search
  search Unsupported("tsvector") @default(dbgenerated("''::tsvector"))

  @@unique([groupId, uid])
  @@index([search], type: Gin)
}

enum Visibility {
  Private
  Unlisted
  GroupRestricted
  SchoolRestricted
  Public
}

/// An event manager is a user that can scan tickets, and may be able to manage the event
model EventManager {
  eventId                String
  userId                 String
  canVerifyRegistrations Boolean @default(true) // Can scan tickets
  canEdit                Boolean @default(false)
  canEditPermissions     Boolean @default(false)

  event Event @relation(fields: [eventId], references: [id], onUpdate: Cascade, onDelete: Cascade)
  user  User  @relation(fields: [userId], references: [id], onUpdate: Cascade, onDelete: Cascade)

  @@unique([eventId, userId])
}

/// A ticket group allows for conditions on multiple tickets, such as an upper limit on the sum of registrations in the sub-tickets
model TicketGroup {
  id      String @id @default(dbgenerated("nanoid('tg:')"))
  eventId String
  name    String @db.VarChar(255)

  capacity Int      @default(0) // 0 means unlimited, capacity is on the sum of sub-tickets registrations
  tickets  Ticket[]
  event    Event    @relation(fields: [eventId], references: [id])

  @@unique([eventId, name])
}

/// A ticket is a way to register for an event. May include a price and conditions.
model Ticket {
  id                    String          @id @default(dbgenerated("nanoid('t:')"))
  uid                   String
  eventId               String
  ticketGroupId         String?
  name                  String          @db.VarChar(255)
  description           String          @db.VarChar(255)
  opensAt               DateTime?
  closesAt              DateTime?
  price                 Float // in EUR
  capacity              Int             @default(0) // 0 means unlimited
  registrations         Registration[]
  links                 Link[]
  allowedPaymentMethods PaymentMethod[] @default([]) // empty means all

  // Conditions for that ticket.
  openToPromotions   Int[]    @default([])
  openToAlumni       Boolean? @default(false) // false means only non-alumni, true means only alumni, null means both
  openToExternal     Boolean? @default(false) // same thing
  openToContributors Boolean? @default(false) // same thing
  openToApprentices  Boolean? // same thing
  openToSchools      School[]
  openToMajors       Major[]
  openToGroups       Group[]  @relation("openTo")
  godsonLimit        Int      @default(0) // 0 means unlimited
  autojoinGroups     Group[]  @relation("autojoin")

  onlyManagersCanProvide Boolean @default(false)

  event               Event        @relation(fields: [eventId], references: [id], onUpdate: Cascade, onDelete: Cascade)
  group               TicketGroup? @relation(fields: [ticketGroupId], references: [id], onDelete: SetNull, onUpdate: Cascade)
  subjectToPromotions Promotion[]

  @@unique([eventId, ticketGroupId, uid])
}

/// A reservation is a user's registration for a ticket
model Registration {
  id            String         @id @default(dbgenerated("nanoid('r:')"))
  ticketId      String
  beneficiary   String
  authorId      String?
  authorEmail   String         @default("")
  verifiedById  String?
  opposedById   String?
  cancelledById String?
  createdAt     DateTime       @default(now())
  updatedAt     DateTime       @updatedAt
  paymentMethod PaymentMethod?
  paid          Boolean        @default(false)

  lydiaTransaction  LydiaTransaction?
  paypalTransaction PaypalTransaction?
  ticket            Ticket             @relation(fields: [ticketId], references: [id], onUpdate: Cascade, onDelete: Cascade)
  author            User?              @relation(name: "author", fields: [authorId], references: [id], onUpdate: Cascade, onDelete: Cascade)
  verifiedBy        User?              @relation(name: "verifiedBy", fields: [verifiedById], references: [id], onUpdate: Cascade, onDelete: SetNull)
  verifiedAt        DateTime?
  opposedBy         User?              @relation(name: "opposedBy", fields: [opposedById], references: [id], onUpdate: Cascade, onDelete: SetNull)
  opposedAt         DateTime?
  cancelledBy       User?              @relation(name: "cancelledBy", fields: [cancelledById], references: [id], onDelete: SetNull, onUpdate: Cascade)
  cancelledAt       DateTime?

  search Unsupported("tsvector") @default(dbgenerated("''::tsvector"))

  @@index([search], type: Gin)
}

enum PaymentMethod {
  Lydia
  PayPal
  Card
  Transfer
  Check
  Cash
  Other
}

/// A log entry is a log of an action that happened on the website
model LogEntry {
  id         String   @id @default(dbgenerated("nanoid('log:')"))
  happenedAt DateTime @default(now())
  userId     String?
  area       String   @db.VarChar(255) // billeterie, gestion clubs, etc. à typer, mais pas dans la DB (pour être plus flexible)
  action     String   @db.VarChar(255)
  target     String?  @db.VarChar(255)
  message    String   @db.Text

  user User? @relation(fields: [userId], references: [id], onUpdate: Cascade, onDelete: SetNull)
}

/// A Lydia account
model LydiaAccount {
  id                   String               @id @default(dbgenerated("nanoid('lydia:')"))
  groupId              String?
  group                Group?               @relation(fields: [groupId], references: [id], onUpdate: Cascade, onDelete: Cascade)
  name                 String               @default("") @db.VarChar(255)
  privateToken         String               @default("") @db.VarChar(255)
  vendorToken          String               @default("") @db.VarChar(255)
  events               Event[]
  studentAssociation   StudentAssociation?  @relation(fields: [studentAssociationId], references: [id])
  studentAssociationId String?
  ContributionOption   ContributionOption[]

  @@unique([privateToken, vendorToken, groupId])
}

// Lydia payment
model LydiaTransaction {
  id                               String        @id @default(dbgenerated("nanoid('lydiapayment:')"))
  phoneNumber                      String        @default("") @db.VarChar(255)
  registrationId                   String?       @unique
  registration                     Registration? @relation(fields: [registrationId], references: [id], onUpdate: Cascade, onDelete: Cascade)
  requestId                        String?
  requestUuid                      String?
  transactionId                    String?
  createdAt                        DateTime      @default(now())
  updatedAt                        DateTime      @updatedAt
  contribution                     Contribution? @relation(fields: [studentAssociationContributionId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  studentAssociationContributionId String?       @unique
}

enum PayPalTransactionStatus {
  Created
  Saved
  Approved
  Voided
  Completed
  PayerActionRequired
}

/// Paypal payment
model PaypalTransaction {
  id             String                   @id @default(dbgenerated("nanoid('paypalpayment:')"))
  emailAddress   String                   @default("") @db.VarChar(255)
  registrationId String?                  @unique
  registration   Registration?            @relation(fields: [registrationId], references: [id], onUpdate: Cascade, onDelete: Cascade)
  status         PayPalTransactionStatus?

  /// PayPal's order ID. 
  orderId   String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

/// A bar week is a week during which some groups takeover the bar staff
model BarWeek {
  id          String   @id @default(dbgenerated("nanoid('barweek:')"))
  uid         String   @unique
  groups      Group[]
  startsAt    DateTime
  endsAt      DateTime
  description String   @default("") @db.VarChar(255)
}

/// A NotificationSubscription stores a user's subscription to push notifications on a user agent
model NotificationSubscription {
  id            String         @id @default(dbgenerated("nanoid('notifsub:')"))
  name          String         @default("") @db.VarChar(255)
  createdAt     DateTime       @default(now())
  updatedAt     DateTime       @updatedAt
  owner         User           @relation(fields: [ownerId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  ownerId       String
  endpoint      String         @unique
  expiresAt     DateTime?
  authKey       String
  p256dhKey     String
  notifications Notification[]
}

/// A notification is a push notification that was sent to a user
model Notification {
  id             String                   @id @default(dbgenerated("nanoid('notif:')"))
  createdAt      DateTime                 @default(now())
  updatedAt      DateTime                 @updatedAt
  timestamp      DateTime?
  subscription   NotificationSubscription @relation(fields: [subscriptionId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  subscriptionId String
  image          String                   @default("")
  actions        Link[]
  title          String                   @db.VarChar(255)
  imageFile      String                   @default("")
  body           String                   @db.Text
  vibrate        Int[]                    @default([])
  group          Group?                   @relation(fields: [groupId], references: [id], onDelete: SetNull, onUpdate: Cascade)
  groupId        String?
  channel        NotificationChannel      @default(Other)
  user           User?                    @relation(fields: [userId], references: [id], onDelete: SetNull, onUpdate: Cascade)
  userId         String?
  goto           String                   @default("")
}

/// A NotificationChannel represents the different kinds of reasons why you might receive a notification: a shotgun just opened, etc.
enum NotificationChannel {
  Articles
  Shotguns
  Permissions
  GroupBoard
  GodparentRequests
  Comments
  Other // should't be used too much
}

/// Announcement is a way to get a message accross the entire site, such as for maintenance announcements.
model Announcement {
  id        String   @id @default(dbgenerated("nanoid('ann:')"))
  by        User?    @relation(fields: [userId], references: [id], onDelete: SetNull, onUpdate: Cascade)
  userId    String?
  title     String   @db.VarChar(255)
  body      String   @db.Text
  warning   Boolean
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  startsAt  DateTime
  endsAt    DateTime
}

model TeachingUnit {
  id         String    @id @default(dbgenerated("nanoid('ue:')"))
  name       String    @db.VarChar(255)
  shortName  String    @default("") @db.VarChar(255)
  apogeeCode String?   @db.VarChar(255)
  subjects   Subject[]
}

model Subject {
  id             String        @id @default(dbgenerated("nanoid('subj:')"))
  name           String
  uid            String
  shortName      String        @default("") @db.VarChar(255)
  yearTier       Int?
  forApprentices Boolean       @default(false)
  links          Link[]
  apogeeCode     String?       @db.VarChar(255)
  unitId         String?
  unit           TeachingUnit? @relation(fields: [unitId], references: [id], onDelete: SetNull, onUpdate: Cascade)
  nextExamAt     DateTime?
  majors         Major[]
  minors         Minor[]
  documents      Document[]
  // 1 for the first semester, 2 for the second one. Null means both
  semester       Int?
  emoji          String        @default("") @db.VarChar(4)

  @@unique([uid, yearTier, forApprentices])
}

enum DocumentType {
  // Graded
  Exam // Partiel
  PracticalExam // BE
  GradedExercises // DM

  // Ungraded
  Exercises // TD
  Practical // TP
  CourseNotes // CM
  CourseSlides // Diapos
  Summary // Fiche de rev, Fiche

  Miscellaneous // Divers
}

model Document {
  id         String   @id @default(dbgenerated("nanoid('doc:')"))
  uid        String
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  schoolYear Int // stored using the school year start's year

  title         String
  description   String       @db.Text
  // Null subject means the document needs to be sorted
  subject       Subject?     @relation(fields: [subjectId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  subjectId     String?
  type          DocumentType
  paperPaths    String[] // le sujet 
  solutionPaths String[] // la correction

  uploader   User?   @relation(fields: [uploaderId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  uploaderId String?

  comments  Comment[]
  reactions Reaction[]

  search Unsupported("tsvector") @default(dbgenerated("''::tsvector"))

  @@unique([subjectId, uid])
  @@index([search], type: Gin)
}

model Comment {
  id        String   @id @default(dbgenerated("nanoid('comment:')"))
  authorId  String?
  body      String   @db.Text
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  author    User?    @relation(fields: [authorId], references: [id], onDelete: Cascade, onUpdate: Cascade)

  document   Document? @relation(fields: [documentId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  documentId String?
  article    Article?  @relation(fields: [articleId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  articleId  String?

  inReplyTo   Comment?   @relation(name: "reply", fields: [inReplyToId], references: [id], onDelete: SetNull, onUpdate: Cascade)
  inReplyToId String?
  replies     Comment[]  @relation(name: "reply")
  reactions   Reaction[]
}

model Reaction {
  id    String @id @default(dbgenerated("nanoid('reac:')"))
  emoji String

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  author    User?    @relation(fields: [authorId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  authorId  String?

  document   Document? @relation(fields: [documentId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  documentId String?
  article    Article?  @relation(fields: [articleId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  articleId  String?
  event      Event?    @relation(fields: [eventId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  eventId    String?
  comment    Comment?  @relation(fields: [commentId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  commentId  String?

  @@unique([emoji, authorId, documentId])
  @@unique([emoji, authorId, articleId])
  @@unique([emoji, authorId, eventId])
  @@unique([emoji, authorId, commentId])
}

enum PromotionType {
  SIMPPS
  // More to come...
}

model PromotionCode {
  id          String    @id @default(dbgenerated("nanoid('promocode:')"))
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  claimedAt   DateTime?
  code        String    @unique
  claimedBy   User?     @relation(fields: [claimedById], references: [id])
  claimedById String?
  promotion   Promotion @relation(fields: [promotionId], references: [id])
  promotionId String
}

model Promotion {
  id         String          @id @default(dbgenerated("nanoid('promo:')"))
  createdAt  DateTime        @default(now())
  updatedAt  DateTime        @updatedAt
  validUntil DateTime?
  type       PromotionType
  codes      PromotionCode[]
  validOn    Ticket[]

  priceOverride Int
}
